"use strict";(self.webpackChunkmilkomeda_documentation=self.webpackChunkmilkomeda_documentation||[]).push([[6907],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(a),u=r,h=c["".concat(s,".").concat(u)]||c[u]||m[u]||i;return a?n.createElement(h,o(o({ref:t},p),{},{components:a})):n.createElement(h,o({ref:t},p))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},798:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var n=a(7462),r=(a(7294),a(3905));const i={sidebar_position:2},o="Protocol Components",l={unversionedId:"cardano/liquid-staking/for_developers/for_developers",id:"cardano/liquid-staking/for_developers/for_developers",title:"Protocol Components",description:"Milkomeda Liquid Staking protocol consists of three upgradeable smart contracts, deployed through an ERC1967Proxy. The core logic resides primarily in the Liquid Staking contract. This contract features a set of public functions that can be invoked by either DApps or individual users. Additionally, it contains an exclusive function designed for depositing rewards, which is solely callable via the Milkomeda Bridge.",source:"@site/docs/cardano/liquid-staking/for_developers/for_developers.md",sourceDirName:"cardano/liquid-staking/for_developers",slug:"/cardano/liquid-staking/for_developers/",permalink:"/ja/cardano/liquid-staking/for_developers/",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"cardano",previous:{title:"Overview",permalink:"/ja/cardano/liquid-staking/for_developers/protocol_overview"},next:{title:"Integrating Liquid Staking",permalink:"/ja/cardano/liquid-staking/for_developers/integrating"}},s={},d=[{value:"Contracts",id:"contracts",level:2},{value:"LiquidStaking",id:"liquidstaking",level:3},{value:"Variables",id:"variables",level:4},{value:"Functions",id:"functions",level:4},{value:"Claiming rewards",id:"claiming-rewards",level:4},{value:"Dead Shares",id:"dead-shares",level:4},{value:"StakedMADA (stMADA)",id:"stakedmada-stmada",level:3},{value:"Pillage",id:"pillage",level:3},{value:"Example:",id:"example",level:4}],p={toc:d};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"protocol-components"},"Protocol Components"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Milkomeda Liquid Staking")," protocol consists of three upgradeable smart contracts, deployed through an ERC1967Proxy. The core logic resides primarily in the Liquid Staking contract. This contract features a set of public functions that can be invoked by either DApps or individual users. Additionally, it contains an exclusive function designed for depositing rewards, which is solely callable via the Milkomeda Bridge."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Contract"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LiquidStaking"),(0,r.kt)("td",{parentName:"tr",align:null},"The core staking contract")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"StakedMADA"),(0,r.kt)("td",{parentName:"tr",align:null},"A ERC20 like token used to represent stakers share of the pool")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Pillage"),(0,r.kt)("td",{parentName:"tr",align:null},"A utility contract to withdraw rewards from smart contract account unable to withdraw their rewards")))),(0,r.kt)("p",null,"You can find the audit on the Liquid Staking smart contracts ",(0,r.kt)("a",{parentName:"p",href:"https://www.milkomeda.com/docs/liquid-staking-final-report-updated.pdf"},"here"),"."),(0,r.kt)("h2",{id:"contracts"},"Contracts"),(0,r.kt)("h3",{id:"liquidstaking"},"LiquidStaking"),(0,r.kt)("h4",{id:"variables"},"Variables"),(0,r.kt)("p",null,"The Staking Smart Contract keeps the count of the total ",(0,r.kt)("em",{parentName:"p"},"mADA")," available in total and for each user. There are at least three variables that track the movements of ",(0,r.kt)("em",{parentName:"p"},"mADA")," native tokens:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"userDeposit"),": a mapping of the amount of ",(0,r.kt)("em",{parentName:"p"},"mADA")," the user has as balance (includes deposits + claimed rewards)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"totalDeposited"),": the total amount of ",(0,r.kt)("inlineCode",{parentName:"p"},"userDeposit"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"totalRewards"),": the total unclaimed rewards deposited up until this point by the Milkomeda DAO"))),(0,r.kt)("h4",{id:"functions"},"Functions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"stake"))),(0,r.kt)("p",{parentName:"li"},"  Every time the ",(0,r.kt)("inlineCode",{parentName:"p"},"stake")," method is executed, a specific amount of shares is minted in favor of the caller, based on the value sent. This is due to a double accounting system shared by the LiquidStaking and the ",(0,r.kt)("em",{parentName:"p"},"stMADA")," Token smart contracts."),(0,r.kt)("p",{parentName:"li"},"  In order to calculate the number of shares to be minted, the LiquidStaking contract keeps track of the total deposited in ",(0,r.kt)("em",{parentName:"p"},"mADA")," while the Staked ",(0,r.kt)("em",{parentName:"p"},"mADA")," Token keeps track of the percentage ownership of each user in relation to the total ",(0,r.kt)("em",{parentName:"p"},"mADA")," deposited."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"    function stake() external returns (uint256);\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"stake")," function with emit the ",(0,r.kt)("inlineCode",{parentName:"p"},"Staked")," event"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"    event Staked(\n        address indexed account,\n        uint256 indexed milkAdaDeposited,\n        uint256 indexed sharesReceived\n    );\n\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Sending mADA to the liquid staking contract will indirectly call the ",(0,r.kt)("em",{parentName:"p"},"stake")," function for the value sent"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"    fallback() external payable {\n        stake();\n    }\n"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"unstake"))),(0,r.kt)("p",{parentName:"li"},"  The unstake with exchange stMADA for mADA."),(0,r.kt)("p",{parentName:"li"},"  When the method ",(0,r.kt)("inlineCode",{parentName:"p"},"unstake")," is executed, the ",(0,r.kt)("inlineCode",{parentName:"p"},"withdrawRewards")," is called internally on behalf of the user and the additional rewards are deposited to them (needed to calculate the number of shares to burn)"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"    function unstake(uint256 _amount) external returns (uint256, uint256);\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"unstake")," function with trigger the ",(0,r.kt)("inlineCode",{parentName:"p"},"Unstaked")," event."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"    event Unstaked(\n        address indexed account,\n        uint256 indexed sharesToWithdraw,\n        uint256 indexed milkAdaAmountToWithdraw\n    );\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"withdrawRewards"))),(0,r.kt)("p",{parentName:"li"},"  This function converts the unclaimed rewards of the caller to user stMADA balance. All externally owned accounts (EOA) have the assumption that they are capable of withdrawing rewards. For smart contract accounts, see ",(0,r.kt)("a",{parentName:"p",href:"/cardano/liquid-staking/for_developers/#claiming-rewards"},"claim rewards")),(0,r.kt)("p",{parentName:"li"},"  Since rewards are accumulated on each distribution, users do not need to call this function every epoch"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"    function withdrawRewards() external returns (uint256);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"removeRewardsOnBehalf")),(0,r.kt)("p",{parentName:"li"},"  This is an access controlled function that can only be called by the Milkomeda DAO to claim rewards for a smart contract that cannot claim its own rewards."),(0,r.kt)("p",{parentName:"li"},"  See below ",(0,r.kt)("a",{parentName:"p",href:"/cardano/liquid-staking/for_developers/#claiming-rewards"},"claim rewards")))),(0,r.kt)("h4",{id:"claiming-rewards"},"Claiming rewards"),(0,r.kt)("p",null,"Rewards can be claimed on every epoch (unlike Cardano where there is a wait period of multiple epochs before the first reward). Both dApps and EOAs also accrue ",(0,r.kt)("em",{parentName:"p"},"stmADA")," and can claim the staking rewards of any token they've accrued."),(0,r.kt)("p",null,"However, to avoid staking rewards accumulating forever in dApps that will never be able to claim the rewards because they didn't implement that functionality, the Milkomeda DAO has a feature where it can claim the rewards on behalf of a smart contract that it judges unable to ever claim the rewards."),(0,r.kt)("p",null,"Because the Milkomeda DAO has no way to know that every smart contract that can hold stMADA has implemented method to claim rewards, the smart contract should explicitly implement a method called ",(0,r.kt)("inlineCode",{parentName:"p"},"ableToWithdrawRewards")," that returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," or else it might have its rewards claimed by the Milkomeda DAO."),(0,r.kt)("p",null,"A smart contract that intends to hold stMADA, should:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Ensure the contract has a way of calling with ",(0,r.kt)("inlineCode",{parentName:"li"},"withdrawRewards")," function of the liquid staking contract")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function withdrawRewards() external returns (uint256 _rewardsInmADA);\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Ensure the contract has a ",(0,r.kt)("inlineCode",{parentName:"li"},"ableToWithdrawRewards")," that returns true (a-la EIP-165). If the contract does not have a ",(0,r.kt)("inlineCode",{parentName:"li"},"ableToWithdrawRewards")," function, your dApp will ",(0,r.kt)("strong",{parentName:"li"},"forfeit")," any staking rewards accrued by the ",(0,r.kt)("em",{parentName:"li"},"stMADA")," held in the smart contract")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function ableToWithdrawRewards() external pure returns (bool) {\n    return true;\n}\n")),(0,r.kt)("p",null,"Optionally, ",(0,r.kt)("inlineCode",{parentName:"p"},"stake")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"unstake")," functions can be implemented to convert to/from ",(0,r.kt)("em",{parentName:"p"},"mADA")),(0,r.kt)("p",null,"Additionally, note that the default behavior when sending ",(0,r.kt)("em",{parentName:"p"},"MADA")," to the liquid staking contract is to stake the tokens. For example, you can implement the stake function wrapper as seen below"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function stake(uint256 _amountToStake) external {\n    payable(stakingSmartContractAddress).transfer(_amountToStake);\n}\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"Context on ",(0,r.kt)("inlineCode",{parentName:"strong"},"ableToWithdrawRewards"))),(0,r.kt)("p",{parentName:"admonition"},"There were at 2 ways of checking whether or not a contract could claim rewards :"),(0,r.kt)("ol",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ol"},"A static call following EIP-165. This costs 3,698 every time Milkomeda DAO attempts to withdraw rewards on behalf of a particular account. The downsides are that it requires work on the smart contract implementer and, if they forget to add the ",(0,r.kt)("inlineCode",{parentName:"li"},"ableToWithdrawRewards")," function, they can't add it later without upgrading their contract"),(0,r.kt)("li",{parentName:"ol"},"Maintaining a map of whether or not a particular contract has claimed rewards in the past so that once a contract claims rewards once, the DAO can no longer claim on their behalf. Other than censorship concerns, this would also cost 22,257 gas to initially add an entry into the map (higher initial cost for lower read cost)")),(0,r.kt)("p",{parentName:"admonition"},"Due to both the censorship concerns and the higher initial cost, Milkomeda implemented the first option (1).")),(0,r.kt)("h4",{id:"dead-shares"},"Dead Shares"),(0,r.kt)("p",null,"To mitigate against inflation attacks, we stake on initialization of the ",(0,r.kt)("strong",{parentName:"p"},"Liquid Staking contract"),", creating dead shares. In order to create dead shares, a value (",(0,r.kt)("inlineCode",{parentName:"p"},"msg.value")," > 0) must be sent when initializating the staking contract. And this value is used to create the first stake in the pool, which is needed to protect against inflation attacks. Creating dead shares doesn't entirely solve this problem, but it reduces the profit that could be made from it .This dead shares is minted to the deployer - it's expected this shares and stake will never be withdrawn, unstaked or redeemed"),(0,r.kt)("h3",{id:"stakedmada-stmada"},"StakedMADA (stMADA)"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"stMADA")," is an ERC20-like token - though it's not a rebase token, it still doesn't fully comply with the ERC20 standard. Modifications have been made to some of its functions, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"transferFrom")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"balanceOf"),". On top of that, the ",(0,r.kt)("inlineCode",{parentName:"p"},"mint")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"burn")," methods have been protected by roles: only the Staking Smart Contract can call those methods. While it could have been possible to inherit the ERC20 contract from Open Zeppelin, it was more than necessary to only comply with the interface (IERC20) since several methods have custom implementations."),(0,r.kt)("p",null,"The contract only emits a Tranfer event when an explicit transfer occurs between holders. From the ERC20 standard the Transfer amount or value in the transfer signature represents the amount of the token sent. Though in the StakedMADA contract, while it still represents the amount being sent, it's not the amount of tokens, but the amount of mADA. A new event (TransferShares) has been added. This event has the same signature and can be seen as replicating the Tranfer event in the ERC20 standard; all that differs is the name."),(0,r.kt)("p",null,"The main reason for implementing customized complying methods is that there are two account systems within the token: one that is shares-based and another one that represents the equivalence one to one with the amount of mADA deposited. After staking an X amount of ",(0,r.kt)("em",{parentName:"p"},"mADA"),", an Y amount of shares are minted for the user. However, he will only know about the total amount of ",(0,r.kt)("em",{parentName:"p"},"mADA")," deposited, which will be represented by the ",(0,r.kt)("em",{parentName:"p"},"stMADA")," Token that he will see in his wallet balance."),(0,r.kt)("p",null,"Let's see how the methods are affected:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"balanceOf")),(0,r.kt)("p",{parentName:"li"},"  Returns back the amount of ",(0,r.kt)("em",{parentName:"p"},"mADA")," deposited by the user in the LiquidStaking smart contract. The token ",(0,r.kt)("em",{parentName:"p"},"stMADA")," does not keep the count of the total ",(0,r.kt)("em",{parentName:"p"},"mADA")," deposited. Hence, when the method ",(0,r.kt)("inlineCode",{parentName:"p"},"balanceOf")," is consulted, internally an inter-contract call is executed. The Staking Smart Contract responds to this query and returns the amount of ",(0,r.kt)("em",{parentName:"p"},"mADA")," deposited by a particular user. When the balance is shown, it's portrayed as ",(0,r.kt)("em",{parentName:"p"},"stMADA")," Token."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'    function balanceOf(\n        address _account\n    ) public view override returns (uint256) {\n        bytes memory returndata = _staticcall(\n            abi.encodeWithSignature("balanceOf(address)", _account),\n            stakingSCProxy\n        );\n\n        return abi.decode(returndata, (uint256));\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"totalSupply")),(0,r.kt)("p",{parentName:"li"},"  Another inter-contract call is necessary to grab the total of ",(0,r.kt)("em",{parentName:"p"},"mADA")," deposited, which is stored in the LiquidStaking smart contract. In other words, ",(0,r.kt)("inlineCode",{parentName:"p"},"totalSupply")," does not return the total number of minted shares but rather the total amount of ",(0,r.kt)("em",{parentName:"p"},"mADA")," deposited by all users."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'    function totalSupply() public view override returns (uint256) {\n        bytes memory returndata = _staticcall(\n            abi.encodeWithSignature("totalDeposited()"),\n            stakingSCProxy\n        );\n\n        return abi.decode(returndata, (uint256));\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"transfer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"transferFrom")),(0,r.kt)("p",{parentName:"li"},"  All methods that involve the movements of funds that are executed have as input a specific amount of mADA Token. After all, the user is only aware of the amount of ",(0,r.kt)("em",{parentName:"p"},"mADA")," deposited represented by ",(0,r.kt)("em",{parentName:"p"},"stMADA")," Token."),(0,r.kt)("p",{parentName:"li"},"  When the methods ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"transferFrom")," are called, the amount of ",(0,r.kt)("em",{parentName:"p"},"mADA")," received is converted to shares to make the necessary updates. "),(0,r.kt)("p",{parentName:"li"},"  Since there is a double accounting system, aside from updating the number of shares one particular account has after the transfer of ",(0,r.kt)("em",{parentName:"p"},"mADA"),", it's also required to update the balances of ",(0,r.kt)("em",{parentName:"p"},"mADA")," deposited in the LiquidStaking smart contract. For that reason, these two methods (",(0,r.kt)("inlineCode",{parentName:"p"},"transfer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"transferFrom"),") have side effects on the other smart contract (the Liquid Staking contract). The side effect simply decreases the count of ",(0,r.kt)("em",{parentName:"p"},"mADA")," deposited in the sender and adds that exact amount to the count of the receiver."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function sideEffectTransferMilkAda(...) \u2026 {\n    ...\n    userDeposit[_from] -= _milkAdaAmount;\n    userDeposit[_to] += _milkAdaAmount;\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"mint")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"burn")),(0,r.kt)("p",{parentName:"li"},"  These two methods can only be called by the LiquidStaking contract. In the same fashion as the two methods described above, before calling ",(0,r.kt)("inlineCode",{parentName:"p"},"mint")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"burn")," the input of ",(0,r.kt)("em",{parentName:"p"},"mADA")," amount is converted into shares.\nThe only place where ",(0,r.kt)("inlineCode",{parentName:"p"},"mint")," is called is within the ",(0,r.kt)("inlineCode",{parentName:"p"},"stake")," method of the LiquidStaking smart contract. Inversely, ",(0,r.kt)("inlineCode",{parentName:"p"},"burn")," is only called when the user wants to ",(0,r.kt)("inlineCode",{parentName:"p"},"unstake")," the total ",(0,r.kt)("em",{parentName:"p"},"mADA")," deposited.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"increaseAllowance"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"decreaseAllowance"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"approve")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"allowance")),(0,r.kt)("p",{parentName:"li"},"  All these methods are performed with the input of ",(0,r.kt)("em",{parentName:"p"},"mADA")," amount, not the shares. The user through ",(0,r.kt)("inlineCode",{parentName:"p"},"balanceOf")," would be able to know the amount of mADA deposited and not the number of minted shares. Hence, it makes sense to work these methods with his ",(0,r.kt)("em",{parentName:"p"},"mADA")," balance."))),(0,r.kt)("h3",{id:"pillage"},"Pillage"),(0,r.kt)("p",null,"Contracts that do not implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"ableToWithdrawRewards")," function, as explained ",(0,r.kt)("a",{parentName:"p",href:"/cardano/liquid-staking/for_developers/#claiming-rewards"},"here"),", signal that they forfeit their staking rewards, and these rewards could be pillaged by the Milkomeda DAO."),(0,r.kt)("p",null,"When an account is Pillaged, its accumulated rewards are removed and the value is automatically staked on behalf of the pillager (Milkomeda DAO)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'    function pillage(address _account, bytes32 _transactionId) external {\n        // Ensure the msg.sender is a validator\n        _assertValidator(msg.sender);\n\n        // Add the validator vote, encoding the the data to be executed.\n        // The staking smart contract has a function removeRewardsOnBehalf\n        // that removes the rewards from an account that cannot withdraw rewards\n        // and adds it as a stake for the pillager.\n        Transaction memory transaction = _addTransaction(\n            _transactionId,\n            abi.encodeWithSignature("removeRewardsOnBehalf(address)", _account),\n            stakingSCProxy\n        );\n\n        Status status = _confirmTransaction(_transactionId, transaction);\n        if (status == Status.SUCCESS) {\n            emit Pillaged(_account);\n        }\n    }\n')),(0,r.kt)("h4",{id:"example"},"Example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Smart contract ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," doesn't implement the ",(0,r.kt)("inlineCode",{parentName:"li"},"ableToWithdrawRewards")," function."),(0,r.kt)("li",{parentName:"ul"},"Smart contract ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," holds 5 stmADA and has accrued staking rewards of 3 mADA. "),(0,r.kt)("li",{parentName:"ul"},"Smart contract ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," can then be pillaged by the Milkomeda DAO and its rewards of 3 mADA are withdrawn, and staked on behalf of the pillager. "),(0,r.kt)("li",{parentName:"ul"},"Now the Milkomeda DAO has a stake balance of 3 mADA, and smart contract ",(0,r.kt)("inlineCode",{parentName:"li"},"A")," has a stake balance of 5 mADA, but reward value of 0.")))}m.isMDXComponent=!0}}]);