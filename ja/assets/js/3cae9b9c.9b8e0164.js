"use strict";(self.webpackChunkmilkomeda_documentation=self.webpackChunkmilkomeda_documentation||[]).push([[7854],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=r.createContext({}),l=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=l(a),h=n,u=m["".concat(c,".").concat(h)]||m[h]||d[h]||o;return a?r.createElement(u,s(s({ref:t},p),{},{components:a})):r.createElement(u,s({ref:t},p))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,s=new Array(o);s[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,s[1]=i;for(var l=2;l<o;l++)s[l]=a[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},2948:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>p});var r=a(7462),n=(a(7294),a(3905));const o=a.p+"assets/images/overview-f6516e5eadb320229180f95ef9a01f4c.png",s={sidebar_position:1},i="Overview",c={unversionedId:"cardano/wrapped-smart-contracts/developers/dev_overview",id:"cardano/wrapped-smart-contracts/developers/dev_overview",title:"Overview",description:"Wrapped smart contracts (WSC) are a powerful protocol that enables the execution of Layer 2 smart contracts directly from Layer 1 wallets. This integration is made possible through the provider object, which adheres to the EIP-1193 standard, acting as a bridge between the EVM provider and the Layer 1 provider. By using WSC, EVM DApps can seamlessly communicate with Layer 1 wallets and execute transactions on Layer 2 smart contracts.",source:"@site/docs/cardano/wrapped-smart-contracts/developers/dev_overview.md",sourceDirName:"cardano/wrapped-smart-contracts/developers",slug:"/cardano/wrapped-smart-contracts/developers/dev_overview",permalink:"/ja/cardano/wrapped-smart-contracts/developers/dev_overview",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"cardano",previous:{title:"For Developers",permalink:"/ja/category/for-developers"},next:{title:"How to integrate",permalink:"/ja/cardano/wrapped-smart-contracts/developers/how_to_integrate"}},l={},p=[{value:"Architecture",id:"architecture",level:3},{value:"Protocol Flow",id:"protocol-flow",level:3},{value:"Smart contracts",id:"smart-contracts",level:3}],d={toc:p};function m(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"overview"},"Overview"),(0,n.kt)("p",null,"Wrapped smart contracts (WSC) are a powerful protocol that enables the execution of Layer 2 smart contracts directly from Layer 1 wallets. This integration is made possible through the provider object, which adheres to the ",(0,n.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1193"},"EIP-1193")," standard, acting as a bridge between the EVM provider and the Layer 1 provider. By using WSC, EVM DApps can seamlessly communicate with Layer 1 wallets and execute transactions on Layer 2 smart contracts."),(0,n.kt)("h3",{id:"architecture"},"Architecture"),(0,n.kt)("p",null,"Wrapped Smart Contracts rely on three key components:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Smart Contracts")," - Similar to wallets like Flint or Metamask in Milkomeda C1, users typically have dedicated accounts. To simplify the process, a smart contract called ",(0,n.kt)("inlineCode",{parentName:"p"},"Actor")," is utilized as an account abstraction, executing actions on behalf of the user.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Oracle")," - The Oracle is a node.js JSON-RPC API that facilitates message relay between Layer 1 and Layer 2 actors. It provides essential methods for deploying the ",(0,n.kt)("inlineCode",{parentName:"p"},"Actor")," (using the ",(0,n.kt)("inlineCode",{parentName:"p"},"ActorFactory"),") and executing transactions on behalf of users.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Provider")," - The front-end library injects the provider object based on ",(0,n.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1193"},"EIP-1193")," into the window.ethereum object. This customized provider includes specific methods like ",(0,n.kt)("inlineCode",{parentName:"p"},"eth_sendTransaction")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"eth_requestAccounts"),", which interact with the Layer 1 wallet and transform the result accordingly."))),(0,n.kt)("h3",{id:"protocol-flow"},"Protocol Flow"),(0,n.kt)("p",null,"The full protocol flow is described below for a user interaction for the first time, where an ",(0,n.kt)("inlineCode",{parentName:"p"},"Actor")," proxy smart contract is deployed and linked the user's L1 address. Subsequent calls from the user will be made to that existing existing ",(0,n.kt)("inlineCode",{parentName:"p"},"Actor"),"."),(0,n.kt)("img",{src:o,className:"img-full",alt:"Connect Wallets"}),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"User")," sends request to create ",(0,n.kt)("strong",{parentName:"li"},"Actor")," with the ",(0,n.kt)("inlineCode",{parentName:"li"},"tx_data"),"calling ",(0,n.kt)("strong",{parentName:"li"},"Final SC"),", and get the actor address back. ",(0,n.kt)("inlineCode",{parentName:"li"},"tx_data")," is an encoded transaction which the ",(0,n.kt)("strong",{parentName:"li"},"Actor")," will call on the ",(0,n.kt)("strong",{parentName:"li"},"Final SC"),". (The actor address is derived from the L1 address using the ",(0,n.kt)("inlineCode",{parentName:"li"},"CREATE2")," opcode.)")),(0,n.kt)("ol",{start:2},(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"External")," calls the ",(0,n.kt)("strong",{parentName:"p"},"ActorFactory")," to deploy ",(0,n.kt)("strong",{parentName:"p"},"Actor")," with the ",(0,n.kt)("inlineCode",{parentName:"p"},"tx_data")," calling ",(0,n.kt)("strong",{parentName:"p"},"Final SC"))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"ActorFactory")," deploys ",(0,n.kt)("strong",{parentName:"p"},"Actor")," using CREATE2 based on description of deploy function")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"User")," asserts correct ",(0,n.kt)("strong",{parentName:"p"},"Actor")," address and sends the funds there (through the ",(0,n.kt)("strong",{parentName:"p"},"Bridge"),")")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Bridge")," wraps the funds and sends it to the ",(0,n.kt)("strong",{parentName:"p"},"Actor"))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"External")," listens to the ",(0,n.kt)("strong",{parentName:"p"},"Bridge")," events and once the funds are wrapped it calls execute")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Actor")," calls the ",(0,n.kt)("strong",{parentName:"p"},"FinalSC")," on behalf of ",(0,n.kt)("strong",{parentName:"p"},"User")))),(0,n.kt)("ol",{start:8},(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"After execute is complete, ",(0,n.kt)("strong",{parentName:"p"},"Actor")," calls the withdraw which creates a request to the ",(0,n.kt)("strong",{parentName:"p"},"Bridge"))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Bridge")," unwraps the funds back to the ",(0,n.kt)("strong",{parentName:"p"},"User")))),(0,n.kt)("admonition",{type:"note"},(0,n.kt)("p",{parentName:"admonition"},"Subsequent interactions through Wrapped Smart Contracts will skip steps 2 and 3, since the ",(0,n.kt)("inlineCode",{parentName:"p"},"Actor")," will alread be deployed.")),(0,n.kt)("admonition",{type:"note"},(0,n.kt)("p",{parentName:"admonition"},"The gas is being paid by the Actor smart contract itself, therefore to execute any transaction the actor needs to have enough balance not only to performa the trasaction but also to pay gas. To fund the ",(0,n.kt)("strong",{parentName:"p"},"Actor")," smart contract the ",(0,n.kt)("strong",{parentName:"p"},"User")," should use bridge or the DApp should prompt the wallet to send the funds to the ",(0,n.kt)("strong",{parentName:"p"},"Actor")," through the ",(0,n.kt)("strong",{parentName:"p"},"Bridge"),".")),(0,n.kt)("h3",{id:"smart-contracts"},"Smart contracts"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Contract"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"https://github.com/dcSpark/wrapped-smartcontracts/blob/main/packages/contracts/contracts/Actor.sol"},"Actor")),(0,n.kt)("td",{parentName:"tr",align:null},"a smart contract to be deployed on the Milkomeda Layer 2 that is bound to the specific L1 address. It serves as an account abstraction: it has a balance, a nonce, and can execute signed transactions on behalf of the user.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"https://github.com/dcSpark/wrapped-smartcontracts/blob/main/packages/contracts/contracts/ActorFactory.sol"},"ActorFactory")),(0,n.kt)("td",{parentName:"tr",align:null},"a smart contract deployed on the Milkomeda Layer 2 that is used to deploy actors. It uses CREATE2 opcode to deterministically derive Actor address from the L1 address.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("a",{parentName:"td",href:"https://github.com/dcSpark/wrapped-smartcontracts/blob/main/packages/contracts/contracts/IL1MsgVerify.sol"},"L1MsgVerify")),(0,n.kt)("td",{parentName:"tr",align:null},"is a precompiled contract that is used to verify the signature of the message signed on the Layer 1 mainchain.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"CardanoSigVerification"),(0,n.kt)("td",{parentName:"tr",align:null},"is a precompiled contract that is deprecated, but needed for backwards compatibility with the milkomeda-c1 testnet.")))),(0,n.kt)("p",null,"To verify the signature the actor will use the ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/dcSpark/wrapped-smartcontracts/blob/main/packages/contracts/contracts/IL1MsgVerify.sol"},"L1MsgVerify")," precompiled contract that can verify L1 signatures. The execution will be invoked by the oracle service, which will get exact refund for the gas paid during the execution. |"),(0,n.kt)("p",null,"The ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/dcSpark/wrapped-smartcontracts/blob/main/packages/contracts/contracts/ActorFactory.sol"},"ActorFactory")," has the deploy function the deploy the ",(0,n.kt)("inlineCode",{parentName:"p"},"Actor")," to an address using CREATE2. The address will be hash(0xFF, sender, salt, bytecode),\nwhere sender is factory, so salt has to be, hash(user, tx_data, random) and random can be predictable so it can be block.timestamp."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-javascript"},"  function deploy(string calldata mainchainAddress, bytes32 salt) public returns (Actor) {\n      // Using CREATE2 to have deterministic actor address tied to the `mainchainAddress`\n      Actor actor = new Actor{salt: salt}(mainchainAddress, l1Type);\n\n      emit Deployed(address(actor), mainchainAddress, salt);\n\n      return actor;\n  }\n")),(0,n.kt)("p",null,"Since the new address is the combination of ",(0,n.kt)("inlineCode",{parentName:"p"},"bytecode"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"user")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"tx_data"),", we can be sure that the deployed ",(0,n.kt)("inlineCode",{parentName:"p"},"Actor")," won't be corrupted, and we can also  ssert the address on the clientside."),(0,n.kt)("p",null,"In the ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/dcSpark/wrapped-smartcontracts/blob/main/packages/contracts/tasks/compile.ts"},"compile task")," the ",(0,n.kt)("inlineCode",{parentName:"p"},"Actor")," contract is compiled to yul code and prepended with the code to store the transaction gas limit to storage. The gas limit is crucial to the calculation of used gas and to verify that the oracle acted honestly and didn't provide less gas than user signed and therefore the transaction would run out of gas. The yul code is later compiled to the evm bytecode and edited in the artifacts."))}m.isMDXComponent=!0}}]);