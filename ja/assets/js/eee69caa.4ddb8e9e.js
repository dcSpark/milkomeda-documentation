"use strict";(self.webpackChunkmilkomeda_documentation=self.webpackChunkmilkomeda_documentation||[]).push([[8907],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),u=s(n),h=r,m=u["".concat(l,".").concat(h)]||u[h]||p[h]||o;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var s=2;s<o;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9410:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_label:"Milkomeda Open Oracle"},i="Milkomeda Open Oracle Developer guide",c={unversionedId:"cardano/for-developers/milkomeda_open_oracle",id:"cardano/for-developers/milkomeda_open_oracle",title:"Milkomeda Open Oracle Developer guide",description:"Milkomeda C1 Sidechain is fully operational on Mainnet, which means that it is currently deployed and connected to production version of the Cardano blockchain.",source:"@site/docs/cardano/for-developers/milkomeda_open_oracle.mdx",sourceDirName:"cardano/for-developers",slug:"/cardano/for-developers/milkomeda_open_oracle",permalink:"/milkomeda-documentation/ja/cardano/for-developers/milkomeda_open_oracle",draft:!1,tags:[],version:"current",frontMatter:{sidebar_label:"Milkomeda Open Oracle"},sidebar:"tutorialSidebar",previous:{title:"\u30a6\u30a9\u30ec\u30c3\u30c8\u306e\u9023\u643a",permalink:"/milkomeda-documentation/ja/cardano/for-developers/wallet-integration"},next:{title:"\u30a8\u30f3\u30c9\u30e6\u30fc\u30b6\u30fc\u5411\u3051",permalink:"/milkomeda-documentation/ja/cardano/for-end-users/"}},l={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Calling Price Feed using Javascript",id:"calling-price-feed-using-javascript",level:2},{value:"Integrate Milkomeda Open Oracle into your Smart Contracts using Hardhat",id:"integrate-milkomeda-open-oracle-into-your-smart-contracts-using-hardhat",level:2},{value:"Summary",id:"summary",level:2}],d={toc:s};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"milkomeda-open-oracle-developer-guide"},"Milkomeda Open Oracle Developer guide"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Milkomeda C1 Sidechain is fully operational on Mainnet, which means that it is currently deployed and connected to production version of the Cardano blockchain.")),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Milkomeda Open Oracle is a decentralized oracle service with a minimal governance system. It permits multiple owners to post data, and the majority of the current owners can add or remove owners. One of its fundamental services is the Price Feed, which offers precise and real-time price data for the USD/ADA pricefeeds. "),(0,r.kt)("p",null,"Sources are checked every ~10 seconds, outliers are removed if the prices they provide differ from the mean by more than 2 standard deviations and the mean of the remaining prices is calculated as the final value. If the new mean price differs from the last price posted on the blockchain by more than 1%, the new mean price is posted and the price is updated on the blockchain."),(0,r.kt)("p",null,"Developers have two options to fetch prices from the oracle contract. They can integrate the oracle interface into their smart contracts, allowing them to access on-chain data updated at regular intervals. Alternatively, developers can call the oracle contract directly with Javascript/Typescript to use the price feed on a DApp frontend."),(0,r.kt)("p",null,"In this guide, we will provide an example of each alternative, requiring the Milkomeda Open Oracle's ABI, which is accessible ",(0,r.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/dcSpark/milkomeda-guides/open_oracle/javascript/Oracle.json"},"here"),", and the contract's deployment address, found in the following table."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Milkomeda C1"),(0,r.kt)("th",{parentName:"tr",align:null},"Open Oracle Deployment address"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Mainnet"),(0,r.kt)("td",{parentName:"tr",align:null},"0xc531410f61FA22e19048D406EDE3361b3de5c386")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Testnet"),(0,r.kt)("td",{parentName:"tr",align:null},"0x47a7d67e89E5714456b9af39703C1dc62203002A")))),(0,r.kt)("p",null,"It is crucial to note that to leverage the capabilities of the Milkomeda Open Oracle, the caller of the read function must agree to the terms of service, which are accessible ",(0,r.kt)("a",{parentName:"p",href:"https://ext-oracle-disclaimer.milkomeda.com/disclaimer.pdf"},"here"),".  This is a one-time requirement (per address), and we will provide guidance on how to accomplish that in this guide."),(0,r.kt)("p",null,"For the purposes of this tutorial, we will be utilizing the Milkomeda C1 Testnet. However, the implementation process is identical on the C1 Mainnet, and the only adjustment necessary would be the deployment address."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"You can choose to follow allong completing the coding steps or download the full code for this tutorial by running:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre"},"npx degit dcspark/milkomeda-guides#open_oracle oracle_guide\n"))),(0,r.kt)("h2",{id:"calling-price-feed-using-javascript"},"Calling Price Feed using Javascript"),(0,r.kt)("p",null,"To call the price feed using Javascript, we will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ethers")," (^6) package, under the assumption that the Terms of Service have not yet been accepted, indicating that the contract is being called for the first time from our address."),(0,r.kt)("p",null,"Let\u2019s create a new javascript project with a script that can be called from the command line. This can easily be adapted to be used for a frontend in a browser.\nNavigate to a new folder where you want to create your project.In a new folder, create an empty project and add the ethers and dotenv packages."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"yarn init -y\nyarn add ethers dotenv\n")),(0,r.kt)("p",null,"Navigate to the root directory of your project. Create a .env file with the private key for the account you intend to use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"PRIVATE_KEY=<PRIVATE_KEY>\n")),(0,r.kt)("p",null,"NOTE: Remember to keep your private key safe from prying eyes. It is recommended to use a new separate account just for testing purposes."),(0,r.kt)("p",null,"Now let\u2019s create a file named \u201ccallPriceFeed.js\u201d and add the imports and initial setup."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const ethers = require("ethers");\nrequire("dotenv").config();\nconst abi = require(\'./Oracle.json\').abi\n\nconst rpcURL = "https://rpc-devnet-cardano-evm.c1.milkomeda.com"\nconst provider = new ethers.JsonRpcProvider(rpcURL)\nconst signer = new ethers.Wallet( `0x${process.env.PRIVATE_KEY}`, provider )\nconst oracle = new ethers.Contract("0x47a7d67e89E5714456b9af39703C1dc62203002A", abi, signer)\n')),(0,r.kt)("p",null,"After importing the ",(0,r.kt)("inlineCode",{parentName:"p"},"ethers")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"dotenv")," package, we\u2019re importing the ",(0,r.kt)("inlineCode",{parentName:"p"},"Oracle.json")," that contains the ABI and setting up a provider, signer and an instance of the oracle contract. Notice we are using the rpc URL and deployment address for Milkomeda C1 Testnet."),(0,r.kt)("p",null,"To get the price feed for USD from the oracle we need to call the readData() function, like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const getPriceFeed = async () => {\n    const price = await oracle.readData()\n    console.log("Price:", ethers.formatEther(price))\n}\n\ngetPriceFeed()\n')),(0,r.kt)("p",null,"However, if you are running the readData function for the first time, the transaction will fail because, although it is a read function, it requires the caller of the function to have accepted the Term of Service. That acceptance is stored in the smart contract as a mapping and can be queried by calling the acceptedTermsOfService function and providing an address."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'oracle.acceptedTermsOfService(signer.address)\n.then(resp => console.log("Accepted Terms of Service:", resp))\n')),(0,r.kt)("p",null,"Making this call should output \u201cAccepted Terms of Service: false\u201d which means that calling the readData() function will fail."),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"getPriceFeed")," function of our script, we can add a test to check if the terms of service have been accepted and call the accept function if needed. Let\u2019s add that to the ",(0,r.kt)("inlineCode",{parentName:"p"},"getPriceFeed")," function."),(0,r.kt)("p",null,"We will also add a function call to retrieve the description of the price feed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'oracle.description().then(resp => console.log("Description:", resp))\n')),(0,r.kt)("p",null,"The final script will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const ethers = require("ethers");\nrequire("dotenv").config();\nconst abi = require(\'./Oracle.json\').abi\n\nconst rpcURL = "https://rpc-devnet-cardano-evm.c1.milkomeda.com"\nconst provider = new ethers.JsonRpcProvider(rpcURL)\nconst signer = new ethers.Wallet( `0x${process.env.PRIVATE_KEY}`, provider )\nconst oracle = new ethers.Contract("0x47a7d67e89E5714456b9af39703C1dc62203002A", abi, signer)\n\n\n// oracle.acceptedTermsOfService(signer.address)\n// .then(resp => console.log("Accepted Terms of Service:", resp))\n\noracle.description()\n.then(resp => console.log("Description:", resp))\n\n\nconst getPriceFeed = async () => {\n    const accepted = await oracle.acceptedTermsOfService(signer.address)\n    if (!accepted) {\n        console.log("Accepting ToS...")\n        const tx = await oracle.acceptTermsOfService();\n        await tx.wait();    \n    }\n    const price = await oracle.readData()\n    console.log("Price:", ethers.formatEther(price))\n}\n\ngetPriceFeed()\n')),(0,r.kt)("p",null,"Running node CallPriceFeed for the first time will output the following lines (the price will probably be different):"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\nDescription: ADA/USD",(0,r.kt)("br",null),"\nAccepting ToS...",(0,r.kt)("br",null),"\nPrice: 2.8398199554148265\n")),(0,r.kt)("p",null,"Subsequent calls to the function, from the same address, will only show the description and the price since the call to ",(0,r.kt)("inlineCode",{parentName:"p"},"acceptedTermsOfService(address)")," will return true."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The result from the price feed,  approx 2.84 (formatted from 18 decimals), is the amount of USD in ADA. Readers are probably used to seeing the price of ADA in USD, which would be the inverse of the result."),(0,r.kt)("p",{parentName:"admonition"},"USD/ADA = 2.8398199554148265"),(0,r.kt)("p",{parentName:"admonition"},"ADA/USD = 1 / (USD/ADA) = 1 / 2.8398199554148265 = 0.352135")),(0,r.kt)("h2",{id:"integrate-milkomeda-open-oracle-into-your-smart-contracts-using-hardhat"},"Integrate Milkomeda Open Oracle into your Smart Contracts using Hardhat"),(0,r.kt)("p",null,"To use the oracle in our smart contract, we need to interact with the oracle contract on the relevant chain while ensuring that our smart contract accepts the terms of service."),(0,r.kt)("p",null,"For testing purposes, we can use Hardhat, a development environment that enables us to compile, deploy, and test smart contracts in a local environment."),(0,r.kt)("p",null,"To set up Hardhat, create a new folder, initialize a JavaScript project, and install Hardhat by executing the following commands in your terminal:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"yarn init -y\nyarn add -D hardhat\n")),(0,r.kt)("p",null,"Once Hardhat is installed, we need to initialize a new Hardhat project:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npx hardhat init\n")),(0,r.kt)("p",null,"This will create a new Hardhat project with a basic directory structure and some example files."),(0,r.kt)("p",null,"Next, we need to create a new smart contract that will use the Milkomeda Open Oracle. Let's call it PriceFeedContract.sol."),(0,r.kt)("p",null,"Create a new file called PriceFeedContract.sol in the contracts directory of your project. Then, add the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    function readData() external view returns (uint256);\n    function acceptTermsOfService() external;\n}\n\ncontract PriceFeedContract {\n    IOracle public oracle;\n \n    constructor() {\n        oracle = IOracle(0x47a7d67e89E5714456b9af39703C1dc62203002A);\n        oracle.acceptTermsOfService();\n    }\n\n    function getPrice() public view returns (uint256 data) {\n        data = oracle.readData();\n    }\n}\n")),(0,r.kt)("p",null,"This smart contract uses a hardcoded deployment address for the oracle on Milkomeda C1 Testnet. When the contract is deployed, the acceptTermsOfService function is called for the contract address in the constructor."),(0,r.kt)("p",null,"The contract has one function, ",(0,r.kt)("inlineCode",{parentName:"p"},"getPrice"),", which retrieves the latest price data and returns it as an integer."),(0,r.kt)("p",null,"To interact with the oracle, we added the interface for the two required functions."),(0,r.kt)("p",null,"Now that we have our smart contract, we need to deploy it to the Milkomeda C1 Testnet. To do this, we will use Hardhat's deployment script. "),(0,r.kt)("p",null,"In the scripts directory of your project, create a new file called deploy.js. Then, add the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const hre = require("hardhat");\n\nasync function main() {\n  const Feed = await hre.ethers.getContractFactory("PriceFeedContract");\n  const feed = await Feed.deploy();\n\n  await feed.deployed();\n  console.log(\n    `PriceFeedContract deployed to ${feed.address}`\n  );\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n')),(0,r.kt)("p",null,"This code uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"ethers.js")," library to deploy our ",(0,r.kt)("inlineCode",{parentName:"p"},"PriceFeedContract")," and logs the address of the deployed contract to the console."),(0,r.kt)("p",null,"To deploy the contract on C1 Testnet, we will create a .env file with the private key of our deployment address:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"PRIVATE_KEY=<PRIVATE_KEY>\n")),(0,r.kt)("p",null,"And we will change the hardhat.config.js by import our account and adding the C1 Testnet to the networks:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'require("@nomicfoundation/hardhat-toolbox");\nrequire("dotenv").config();\n\n/** @type import(\'hardhat/config\').HardhatUserConfig */\nmodule.exports = {\n  solidity: "0.8.18",\n  networks: {\n    c1_testnet: {\n      url: `https://rpc-devnet-cardano-evm.c1.milkomeda.com`,\n      accounts: [`0x${process.env.PRIVATE_KEY}`]\n    }\n  }\n};\n')),(0,r.kt)("p",null,"Now we can deploy our contract. Run the following command in your terminal:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npx hardhat run scripts/deploy.js --network c1_testnet\n")),(0,r.kt)("p",null,"Now that we have deployed our contract, we can call it from another smart contract or from a web3-enabled application.\nTo call the getPrice function from another smart contract, you can simply import the PriceFeedContract and call the getPrice function, but let\u2019s see an example of how to call it from a Hardhat script."),(0,r.kt)("p",null,"Create a file in the scripts folder called \u201ccallPriceFeed.js\u201d and add the code below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'const hre = require("hardhat");\n\nconst getPrice = async () => {\n    const address = \'0x7839D8C1EB9d719Fcf842E968022Ca239451223c\'\n    const feed = await hre.ethers.getContractAt("PriceFeedContract", address);\n\n    const price = await feed.getPrice()\n    console.log(`USD/ADA: ${hre.ethers.utils.formatEther(price)}`)\n}\n  \ngetPrice()\n')),(0,r.kt)("p",null,"Now run it by running the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx hardhat run scripts/call.js --network c1_testnet\n")),(0,r.kt)("p",null,"The result in the terminal should be:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"USD/ADA: 2.8398199554148265")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"In this guide, we explored the Milkomeda Open Oracle, a decentralized oracle service that provides a price feed. We demonstrated two methods for fetching the data: (i) querying price data from the oracle contract using Javascript/Typescript, and (ii) implementing the oracle interface to call the price feed for our own smart contract."),(0,r.kt)("p",null,"It's crucial to note that acceptance of the terms of service is mandatory for the calling address; otherwise, the call will fail."))}p.isMDXComponent=!0}}]);